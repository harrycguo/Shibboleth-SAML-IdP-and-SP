<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:util="http://www.springframework.org/schema/util"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:c="http://www.springframework.org/schema/c"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
                           http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd"
                           
       default-init-method="initialize"
       default-destroy-method="destroy">

    <!--
    This is a map of transition rules that guide the behavior of the MFA flow
    and controls how factors are sequenced, skipped, etc. The key of each entry
    is the name of the step/flow out of which control is passing. The starting
    rule has an empty key.
    
    Each entry is a bean inherited from "shibboleth.authn.MFA.Transition". Per
    the Javadoc for net.shibboleth.idp.authn.MultiFactorAuthenticationTransition:
            
        p:nextFlow (String)
            - A flow to run if the previous step signaled a "proceed" event, for simple
                transitions.
                
        p:nextFlowStrategy (Function<ProfileRequestContext,String>)
            - A function to run if the previous step signaled a "proceed" event, for dynamic
                transitions. Returning null ends the MFA process.
            
        p:nextFlowStrategyMap (Map<String,Object> where Object is String or Function<ProfileRequestContext,String>)
            - Fully dynamic way of expressing control paths. Map is keyed by a previously
                signaled event and the value is a flow to run or a function to
                return the flow to run. Returning null ends the MFA process.
                
    When no rule is provided, there's an implicit "null" that ends the MFA flow
    with whatever event was last signaled. If the "proceed" event from a step is
    the final event, then the MFA process attempts to complete itself successfully.
    -->
    <util:map id="shibboleth.authn.MFA.TransitionMap">
        <!-- First rule runs the External login flow. -->
        <entry key="">
            <bean parent="shibboleth.authn.MFA.Transition" p:nextFlow="authn/External" />
        </entry>

        <!--
        Second rule runs a function if External succeeds, to determine whether an additional
        factor is required.
        -->
        <entry key="authn/External">
            <bean parent="shibboleth.authn.MFA.Transition" p:nextFlowStrategy-ref="checkPasswordlessEligibility" />
        </entry>

        <!-- <entry key="authn/Password">
            <bean parent="shibboleth.authn.MFA.Transition" p:nextFlowStrategy-ref="checkSecondFactor" />
        </entry> -->

        <!-- Third rule decides what to call based on event signaled by the view. -->
        <entry key="authn/Password">
            <bean parent="shibboleth.authn.MFA.Transition">
                <property name="nextFlowStrategyMap">
                    <map>
                        <!-- Default behavior, proceed to Duo -->
                        <!-- <entry key="proceed" value-ref="checkSecondFactor" /> -->

                        <!-- Default behavior, proceed to passwordless -->
                        <entry key="MyCustomEvent" value="authn/SAML" />
                        
                    </map>
                </property>
            </bean>
        </entry>



        <!-- <entry key="authn/SAML">
            <bean parent="shibboleth.authn.MFA.Transition" p:nextFlow="authn/External" />
        </entry> -->
        <!-- An implicit final rule will return whatever the final flow returns. -->
    </util:map>













    <!-- Example script to see if second factor is required. -->
    <bean id="checkPasswordlessEligibility" parent="shibboleth.ContextFunctions.Scripted" factory-method="inlineScript" p:customObject-ref="shibboleth.AttributeResolverService">
        <constructor-arg>
            <value>
            <![CDATA[
                nextFlow = "authn/Password";
                logger = Java.type("org.slf4j.LoggerFactory").getLogger("net.shibboleth.idp.authn");
                logger.info("YOOOOOOO");
                itr = input.iterator();
                logger.info(input);

                while(itr.hasNext()) {
                    element = itr.next();
                    logger.info(element);
                }

                //profileRequestContext = input.getSubcontext("net.shibboleth.idp.profile.context.RelyingPartyContext");
                //logger.info(profileRequestContext);
                //auditContext = input.getSubcontext("net.shibboleth.idp.profile.context.AuditContext");
                //logger.info(auditContext);
                //userAgentContext = input.getSubcontext("net.shibboleth.idp.authn.context.UserAgentContext");
                //logger.info(userAgentContext);
                springRequestContext = input.getSubcontext("net.shibboleth.idp.profile.context.SpringRequestContext");
                logger.info(springRequestContext);
                requestContext = springRequestContext.getRequestContext();
                requestParameters = requestContext.getRequestParameters();
                logger.info("REQUEST CONTEXT");
                logger.info(requestContext.getRequestParameters());
                logger.info("USERNAME:");
                logger.info(requestParameters.get("j_username"));

                //profileInterceptorContext = input.getSubcontext("net.shibboleth.idp.profile.context.ProfileInterceptorContext");
                //logger.info(profileInterceptorContext);
                //eventContext = input.getSubcontext("org.opensaml.profile.context.EventContext");
                //logger.info(eventContext);


                relyingPartyCtx = input.getSubcontext("net.shibboleth.idp.profile.context.RelyingPartyContext");
                logger.info("relying party context");
                logger.info(relyingPartyCtx.getRelyingPartyId());
            
                // Check if second factor is necessary for request to be satisfied.
                authCtx = input.getSubcontext("net.shibboleth.idp.authn.context.AuthenticationContext");
                logger.info("auth context");
                logger.info(authCtx);


                itr = authCtx.iterator();
                logger.info(authCtx);

                while(itr.hasNext()) {
                    element = itr.next();
                    logger.info(element);
                }
                externalCtx = authCtx.getSubcontext("net.shibboleth.idp.authn.context.ExternalAuthenticationContext")
                logger.info("externalCtx");
                logger.info(externalCtx.toString());
                logger.info(externalCtx.getPrincipal());
                logger.info(externalCtx.getPrincipalName());
                logger.info(externalCtx.getSubject());

                mfaCtx = authCtx.getSubcontext("net.shibboleth.idp.authn.context.MultiFactorAuthenticationContext");
                logger.info("mfa context");
                logger.info(mfaCtx.toString());

                // check for status codes here

                // Attribute check is required to decide if first factor alone is enough.
                resCtx = input.getSubcontext("net.shibboleth.idp.authn.context.SubjectCanonicalizationContext");
                logger.info("subject c14n");
                logger.info(resCtx.getPrincipalName());
                //not available in 4.0
                //authCtx.setRequiredName(resCtx.getPrincipalName());

                authStateMap = authCtx.getAuthenticationStateMap();

                authStateMap.put("username", resCtx.getPrincipalName());
                logger.info(resCtx.getSubject());


                // Attribute check is required to decide if first factor alone is enough.
                attrResCtx = input.getSubcontext("net.shibboleth.idp.attribute.resolver.context.AttributeResolutionContext", true);
                // Look up the username using a standard function.
                usernameLookupStrategyClass= Java.type("net.shibboleth.idp.session.context.navigate.CanonicalUsernameLookupStrategy");
                usernameLookupStrategy = new usernameLookupStrategyClass();
                attrResCtx.setPrincipal(usernameLookupStrategy.apply(input));
                attrResCtx.getRequestedIdPAttributeNames().add("affiliation");
                attrResCtx.resolveAttributes(custom);
                logger.info("attr res ctx");
                logger.info(attrResCtx.getResolvedIdPAttributes());

                // Check for an attribute that authorizes use of first factor.
                attribute = attrResCtx.getResolvedIdPAttributes().get("affiliation");
                valueType = Java.type("net.shibboleth.idp.attribute.StringAttributeValue");

                authStateMap.put("passwordlessEligibility", "true");
                if (attribute != null && attribute.getValues().contains(new valueType("alumni"))) {
                    authStateMap.put("passwordlessEligibility", "false");
                }

                logger.info(authStateMap);

              
                nextFlow;   // pass control to second factor or end with the first
            ]]>
            </value>
        </constructor-arg>
    </bean>
    
</beans>
